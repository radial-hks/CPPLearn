#include <iostream>;
using namespace std;
#include <string>;

// 多态是c++面向对象的三大特性之一；
// 多态分类:
// - 静态多态: 函数重载 和 运算符重载，复用函数名；
// - 动态多态：派生类和虚函数实现运行时多态；

// 动态与静态之间的区别:
// 静态多态的函数地址早绑定 - 编译阶段确定函数地址；
// 动态多态的函数地址晚绑定 - 运行阶段确定函数地址；

// 动态多态满足的条件
// 1、有继承关系；
// 2、子类重写父类的虚函数；

// 动态多态使用
// 父类的指针或者引用，执行子类对象；

class Car
{
public:
	// 添加关键字 virtual ，虚函数;
	virtual void run() 
	{
		cout << "行驶在天府大道上" << endl;
	};
};

class WhiteCar :public Car
{
public:
	void run()
	{
		cout << "白色的汽车，行驶在天府大道上" << endl;
	};
};

void Running(Car& car)
{
	// 函数地址早绑定, 编译阶段确定函数地址； -- Car中的run() 
	car.run();
}

void  Test_1()
{
	WhiteCar wc;
	Running(wc);
}

int main_15()
{
	Test_1();
	return 0;
}


// 参考链接: https://zhuanlan.zhihu.com/p/37340242
// 多态性( polymorphisms )可以简单地概括为“一个接口，多种方法”，它是面向对象编程领域的核心概念。

//多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。
//
//编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding
//运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding

//C++运行时多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(Override)，或者称为重写。
//
//多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。
//
//多态的目的：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。
//
//多态最常见的用法就是声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到同一个函数，这就无法实现“一个接口，多种方法”的目的了。
//
//需要注意：
//只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。
//静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。
//内联函数（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。
//构造函数不能是虚函数。
//析构函数可以是虚函数，而且建议声明为虚函数。







// 纯虚函数 与  抽象类；
//C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。
//如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的，

// - 无法实例化对象；
// - 抽象类的子类，必须重写父类中的纯虚函数，否则 ，也属于抽象类;

class Box
{
public:
	// 纯虚函数
	virtual double getVolume() = 0;
private:
	double length;      // 长度
	double breadth;     // 宽度
	double height;      // 高度
};

// 基类
class Shape
{
public:
	// 提供接口框架的纯虚函数
	virtual int getArea() = 0;
	void setWidth(int w)
	{
		width = w;
	}
	void setHeight(int h)
	{
		height = h;
	}
protected:
	int width;
	int height;
};

// 派生类
class Rectangle : public Shape
{
public:
	int getArea()
	{
		return (width * height);
	}
};
class Triangle : public Shape
{
public:
	int getArea()
	{
		return (width * height) / 2;
	}
};